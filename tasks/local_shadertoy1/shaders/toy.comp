#version 450

layout(local_size_x = 32, local_size_y = 32) in;
layout(push_constant) uniform PushParams {
    uint   size_x;
    uint   size_y;
    float  time;
    float  mouse_x;
    float  mouse_y;
} pc;

layout(binding = 0, rgba8) uniform image2D outImage;

#define iTime       (pc.time)
#define iResolution vec2(pc.size_x, pc.size_y)


#define MAX_STEPS 100
#define MAX_DIST  100.0
#define EPSILON   0.001

mat2 rotate2d(float a) {
    float c = cos(a), s = sin(a);
    return mat2(c, -s, s, c);
}

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdPlane(vec3 p) {
    return p.y;
}

float opUnion(float d1, float d2) {
    return min(d1, d2);
}

float mapScene(vec3 p) {
    float bigSphere = sdSphere(p - vec3(0.0, 1.0, 0.0), 1.0);

    float orbitRadius = 2.0;
    float planetX = orbitRadius * sin(iTime);
    float planetZ = orbitRadius * cos(iTime);
    float smallSphere = sdSphere(p - vec3(planetX, 1.0, planetZ), 0.3);

    float plane = sdPlane(p);

    float distScene = opUnion(bigSphere, smallSphere);
    distScene = opUnion(distScene, plane);
    return distScene;
}

vec3 calcNormal(vec3 p) {
    float d = mapScene(p);
    vec2 e = vec2(0.002, 0.0);

    vec3 n;
    n.x = mapScene(p + vec3(e.x, e.y, e.y)) - d;
    n.y = mapScene(p + vec3(e.y, e.x, e.y)) - d;
    n.z = mapScene(p + vec3(e.y, e.y, e.x)) - d;
    return normalize(n);
}

float rayMarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * t;
        float dist = mapScene(p);
        if(dist < EPSILON) {
            return t;
        }
        t += dist;
        if(t > MAX_DIST) break;
    }
    return -1.0;
}

vec3 lighting(vec3 p, vec3 ro, vec3 rd) {
    vec3 n = calcNormal(p);

    vec3 lightPos   = vec3(3.0, 5.0, 3.0);
    vec3 lightColor = vec3(1.0, 0.97, 0.9);

    vec3 L = normalize(lightPos - p);
    float diff = max(dot(n, L), 0.0);

    vec3 R = reflect(-L, n);
    float spec = pow(max(dot(R, -rd), 0.0), 32.0);

    float shadow = 1.0;
    {
        float distToLight = rayMarch(p + n*EPSILON*2.0, L);
        float distLight   = length(lightPos - p);
        if(distToLight > 0.0 && distToLight < distLight) {
            shadow = 0.2;
        }
    }

    vec3 ambient = vec3(0.05);

    vec3 color = ambient
               + lightColor * diff * shadow
               + lightColor * spec * shadow;

    color += 0.05 * n;
    return color;
}

void mainImage(in vec2 fragCoord, out vec4 fragColor)
{
    float flippedY = (iResolution.y - 1.0) - fragCoord.y;
    vec2 uv = (vec2(fragCoord.x, flippedY) - 0.5 * iResolution) / iResolution.y;

    float time   = iTime * 0.2;
    float radius = 5.0;

    vec3 ro = vec3(
        radius * sin(time),
        2.0,
        radius * cos(time)
    );

    vec3 center = vec3(0.0, 1.0, 0.0);

    vec3 cw = normalize(center - ro);
    vec3 cr = normalize(cross(vec3(0,1,0), cw));
    vec3 cu = cross(cw, cr);

    vec3 rd = normalize(uv.x * cr + uv.y * cu + cw);

    float t = rayMarch(ro, rd);

    vec3 skyColorTop = vec3(0.6, 0.8, 1.0);
    vec3 skyColorBot = vec3(0.9, 0.9, 1.0);
    vec3 col = mix(skyColorTop, skyColorBot, uv.y + 0.5);

    if(t > 0.0) {
        vec3 p = ro + rd * t;
        col = lighting(p, ro, rd);
    }

    fragColor = vec4(col, 1.0);
}

void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);

    if(gid.x >= int(pc.size_x) || gid.y >= int(pc.size_y)) {
        return;
    }

    vec4 color;
    mainImage(vec2(gid), color);
    color = clamp(color, 0.0, 1.0);
    imageStore(outImage, gid, color);
}